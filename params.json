{"name":"Lithium","tagline":"Error monitoring","body":"# Lithium - Error monitoring for Neon\r\n\r\nLithium is a Code monitoring tool for Neon. Its main use case is to detect execution events on the JavaScript code such as Errors.\r\n\r\nIt monitors the code at the execution level, so it can be used on live code to detect errors, and notify about this errors to another library or the console.\r\n\r\n## Installation\r\n\r\nLithium depends on a patched version of neon, (provided on this repo).\r\n\r\n```js\r\n<script src=\"./neon.js\"></script>\r\n<script src=\"./neon.li_patch.js\"></script>\r\n<script src=\"./lithium.js\"></script>\r\n\r\n// place other neon based files here.\"\r\n```\r\n\r\n## Usage\r\n\r\nLithium exposes a set of Engines for the execution phases of code.\r\n\r\n- Before execution: This is triggered before the execution of a function.\r\n- Error detection: This is triggered in the case that a function dispatched an error.\r\n- After execution: This is triggered after the function returned the execution control.\r\n\r\nAll of the engines act as a list of functions that will be executed in the order they were added to the engine pool.\r\n\r\nNote that code that was not called by a Lithium monitored code will not detect errors because its not possible to do so. Errors trapped and handled by\r\nyour code will not be detected either (this is a JavaScript behavior).\r\n\r\nThe internal data structure of this engines is a plain Array object so you can modify its values with the vanilla Array methods from JavaScript.\r\n\r\nOn this example we are going to focus on the Error engine.\r\n\r\n```js\r\n/*\r\ndata object contents.\r\ndata = {\r\n    scope : <<Object>>, //The object where the error was detected\r\n    args : <<Array>>, //The arguments that the function received\r\n    spy : <<Object>>, //The reference to the Lithium Object monitoring this function\r\n    error : <<Error>> //The internal JavaScript Error object\r\n}\r\n*/\r\n\r\nLi.Engine.error.push(function (data) {\r\n    console.error(data);\r\n});\r\n\r\n```\r\n\r\n## Advanced Usage\r\n\r\nOn this example we are going to get more information out of the error notification on the Error Engine.\r\n\r\nWe are going to focus on the spy properties.\r\n\r\n```js\r\nspy = {\r\n    targetObject : <<Object>>, //The object that holds the function\r\n    methodName : <<String>>, //The property name where the function lives\r\n    originalMethod : <<Function>>, //The original method of the object\r\n    objectHasMethod : <<Boolean>> //Tells if the method actually lives on the object or lives on the prototype chain\r\n}\r\n\r\nLi.Engine.error.push(function (data) {\r\n    var errorData = [\r\n        'Lithium Detected an Error on ',\r\n        data.scope.className,\r\n        ' on method  ',\r\n        data.spy.methodName,\r\n        ' with message  ',\r\n        data.error.message\r\n    ];\r\n    console.error(errorDatai.join(' '));\r\n    console.error(data.error.stack);\r\n});\r\n```\r\n\r\n\r\n## Enabling or Disabling Lithium\r\n\r\nLithium is enabled by default but there are cases where you don't want this.\r\n\r\nThe first strategy to fully disable it is by running this code after Lithium inclussion.\r\n\r\n```js\r\nenableLi = false;\r\n```\r\n\r\nIf you want to remove Lithium on runtime from a specific object.\r\n\r\n```js\r\nobject.otherObject.__objectSpy.destroy();\r\n```\r\n\r\n## Final notes\r\n\r\nLithium does not require interaction with its code. So there are no methods that you have to run or any instance that you have to create\r\nall its handled by itself.\r\n\r\nYou dont need to code for lithium, it will monitor if you ask it to do so.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}